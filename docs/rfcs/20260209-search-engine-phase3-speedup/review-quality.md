## Technical Quality Reviewer によるレビュー結果

### 1. 判定 (Decision)

- **Status**: Request Changes

**判定基準:** P0 が1件以上存在する場合は Request Changes とする。P0 が0件の場合は Approve とする。

### 2. 良い点 (Strengths)

設計上の重要な判断で妥当と評価できるものを簡潔に記載する。

- 5.1.2 ビットボード合法手生成: `BitboardMobilityGenerator` を静的クラスとして設計し、インスタンス状態を持たない純粋関数として実装する方針は、テスト容易性と構造的簡潔さの観点で優れている。
- 5.3.2 PopCount: `System.Numerics.BitOperations.PopCount` の採用は .NET 標準 API の活用であり、既存コードベースとの一貫性を保ちつつ最小の変更量で効果を得られる設計である。
- 5.2.4 差分更新の実装: XOR の自己逆元性を活用した Zobrist ハッシュ差分更新は、アルゴリズムの原理に忠実で堅牢な設計である。
- 8. テスト戦略: 差分更新後の結果をフルスキャン結果と照合するデバッグアサーションの設計は、差分更新の正しさを継続的に検証できる優れた品質保証手法である。
- 5.4.5 段階的導入: 複雑性に応じた導入順序の設計により、各ステップの検証が独立して可能であり、テスト容易性が確保されている。

### 3. 指摘事項 (Issues)

#### Severity 定義

| Severity | 名称 | 定義 | Author の対応 |
| :--- | :--- | :--- | :--- |
| **P0 (Blocker)** | 修正必須 | 論理的欠陥、仕様漏れ、重大なリスク、回答必須の質問 | 必ず対応 |
| **P1 (Improvement)** | 具体的改善 | 修正内容と期待効果が明確な具体的改善提案 | 原則対応 |
| **P2 (Note)** | 記録のみ | 代替案の提示、将来的な懸念、参考情報 | 対応不要 |

#### 指摘一覧

**[P0-1] MakeMove における裏返し処理のビットボード化と既存 MoveAndReverseUpdater の責務分離が未定義**
- **対象セクション**: 5.1.3 裏返し処理のビットボード化, 5.1.4 MobilityAnalyzer への統合
- **内容**: RFC は `ComputeFlipped` を `BitboardMobilityGenerator` に追加し、裏返し処理のビットボード化を提案している。しかし、現行の `PvsSearchEngine.MakeMove` は `_reverseUpdater.Update(context)` を呼び出して着手を実行しており、この呼び出しがビットボード版にどう置換されるかの具体的な設計が欠落している。`MoveAndReverseUpdater.Update` は着手実行モード（`move < 0`、つまり `context.Move` を使用）で盤面を直接変更するが、ビットボード版ではどのコンポーネントがその責務を担うのか、`PvsSearchEngine.MakeMove` 内のコードがどう変更されるのかが不明確である。この欠落により、実装時に設計判断が分散し、構造的な一貫性が損なわれるリスクがある。
- **修正の期待値**: `PvsSearchEngine.MakeMove` 内での裏返し処理を `BitboardMobilityGenerator.ComputeFlipped` + ビットボード演算に置換する具体的なコード例を示し、`MoveAndReverseUpdater` の着手実行モードとの関係（廃止、共存、ラッパー化など）を明記すること。

**[P0-2] ハッシュ値の伝播設計が具体性を欠いている**
- **対象セクション**: 5.2.5 PvsSearchEngine への統合
- **内容**: 「ルートで `ComputeHash` を 1 回呼び、以降は `UpdateHash` で差分更新」と記載されているが、ハッシュ値を `Pvs` メソッドの引数として渡すのか、`GameContext` のフィールドとして保持するのか、`MoveInfo` から復元するのかの具体的な伝播方式が設計されていない。現行の `Pvs` メソッドはノードごとに `_zobristHash.ComputeHash(context)` を呼んでおり、これを差分更新に置換するには `Pvs` のシグネチャ変更（ハッシュ値のパラメータ追加）または `GameContext` への `CurrentHash` フィールド追加が必要である。いずれの方式を採用するかにより、パス処理、MPC の浅い探索、Aspiration retry での挙動が異なるため、設計段階での明確化が必要である。
- **修正の期待値**: ハッシュ値の伝播方式（メソッド引数方式 or コンテキストフィールド方式）を決定し、`Pvs` メソッド・パス処理・MPC 浅い探索・RootSearch それぞれでのハッシュ値管理の具体的なコード例を追記すること。

**[P1-1] 可観測性の改善が NPS 追加のみで不十分**
- **対象セクション**: 7.3 可観測性
- **内容**: NPS の追加は有用だが、Phase 3 で導入される各最適化の個別効果を計測する手段が設計されていない。ビットボード合法手生成の呼び出し回数、Zobrist ハッシュの差分更新/フルスキャン比率、評価関数の差分更新による平均影響パターン数等のメトリクスがなければ、各最適化の寄与度を定量的に評価できない。
- **修正の期待値**: デバッグビルド限定で、各最適化の個別効果を計測するカウンタ（ビットボード合法手生成回数、差分更新回数、差分更新あたりの平均影響マス数/パターン数）を設計に追加すること。

**[P1-2] 評価関数差分更新のパターンインデックス保存・復元方式が未確定**
- **対象セクション**: 5.4.4 差分更新の統合
- **内容**: 「差分情報（変化マスと変化前の状態）のみ保存する方式とする」と記載されているが、具体的なデータ構造とメモリレイアウトが示されていない。パターンインデックスの保存・復元は MakeMove/UnmakeMove のホットパス上にあるため、`Span<T>` + `stackalloc` か固定サイズバッファかの選択がパフォーマンスに直結する。
- **修正の期待値**: パターンインデックスの保存・復元に使用するデータ構造（`MoveInfo` 内の固定サイズフィールド、`stackalloc` バッファ、または `_preallocatedResults` のスナップショット方式）を具体的に決定し、設計セクションに追記すること。

**[P2-1] `FindFlips` の正シフト/負シフト分岐によるブランチ予測への影響**
- **対象セクション**: 5.1.2 ビットボード合法手生成アルゴリズム
- **内容**: `FindFlips` メソッド内で `shift > 0` による条件分岐があり、8 方向の呼び出しのうち 4 回は正シフト、4 回は負シフトとなる。この分岐は JIT によるインライン化後も残る可能性があり、CPU のブランチ予測器に負荷を与える。方向ごとに専用メソッドに展開するか、テンプレート的な実装で分岐を排除する手法も検討に値する。

**[P2-2] `ConvertToTernaryIndex` の 3 進数計算方式と差分更新の互換性**
- **対象セクション**: 5.4.2 差分更新の原理
- **内容**: 現行の `ConvertToTernaryIndex` は `index *= 3; index += value` のループで MSB 側から計算しているが、差分更新の設計では `w = 3^i`（i はパターン内のマス位置）として LSB 側からの重みを前提としている。この計算方向の違いにより、差分更新の `TernaryWeight` の定義がパターン定義のマス順序に依存する。パターン定義のマス順序と差分更新の重み計算の整合性を実装時に注意深く検証する必要がある。
