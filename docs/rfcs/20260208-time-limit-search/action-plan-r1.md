# レビュー統合アクションプラン（ラウンド 1）

## 判定
- **Status**: Request Changes
- **P0 件数**: 2 件
- **P1 件数**: 6 件（アクション対象: 5 件）
- **P2 件数**: 5 件（記録のみ）

## 必須対応 (P0)

**[P0-1] 終盤完全読み切りモード（depth=99）における時間制御の方針が未定義**
- **出典**: Approach
- **内容**: `FindBestMover` は `TurnCount >= EndgameTurnThreshold` の場合に `depth = 99` で完全読み切りを行うが、セクション 5.6.2 では「完全読み切りモードの時間制御は将来の課題」と記載する一方、セクション 5.6.3 のコード例では終盤モードでも `timeLimitMs` が設定されており矛盾がある。レイヤー 1 の分岐係数 3 倍推定は完全読み切りの特性と合致せず、不適切な打ち切りが発生する可能性がある。
- **修正方針**: 終盤完全読み切りモードにおける時間制御の方針を以下のいずれかで明確化すること。(a) 本 RFC では終盤モードへの `timeLimitMs` 適用を Non-Goals に追記し、コード例から終盤パスの `timeLimitMs` 設定を除外する。(b) 終盤モードでも `timeLimitMs` を適用するが、レイヤー 1 の推定ロジックを終盤用に調整する方針を記載する。

**[P0-2] _nodesSearched のフィールド型が未明記であり、オーバーフロー時にタイムアウトチェックが不達になるリスク**
- **出典**: Quality
- **内容**: `_nodesSearched` の型が RFC 内で明示されていない。`int` 型の場合、長時間の探索で `int.MaxValue`（約 21 億）を超えるとオーバーフローし、ビット AND によるタイムアウトチェック条件が意図通りに動作しなくなる可能性がある。
- **修正方針**: `_nodesSearched` のフィールド定義（型を含む）をセクション 5.5.1 に明記すること。既存コードが `int` 型である場合は `long` 型への変更を変更対象ファイル一覧（セクション 5.7）に追加すること。

## 推奨対応 (P1) — 上位5件

**[P1-1] depth=1 の探索中にタイムアウトが発生した場合、BestMove=-1（無効値）が返却される**
- **出典**: Security
- **内容**: Goals に「最低 depth=1 の探索結果が保証される」と記載があるが、depth=1 の探索中にレイヤー 2 のタイムアウトが発生した場合、`completedDepth = 0` かつ `BestMove = -1` のまま返却される。無効な着手が返却されると呼び出し元で予期しない動作が発生するリスクがある。
- **修正方針**: depth=1 の探索中はレイヤー 2 のタイムアウトチェックを無効化する設計に変更すること。具体的には、タイムアウトチェック条件に `_currentDepth >= 2` のガードを追加する。

**[P1-2] Aspiration Window のリトライ中のタイムアウト挙動が未記載**
- **出典**: Quality
- **内容**: `AspirationRootSearch` は fail-high / fail-low 時にウィンドウを広げてリトライする機構を持つが、リトライ途中で `SearchTimeoutException` が発生した場合の挙動が記載されていない。例外が `AspirationRootSearch` を透過するのか、catch されるのかが不明確である。
- **修正方針**: `AspirationRootSearch` 内で `SearchTimeoutException` が発生した場合、例外は catch せず `Search()` の反復深化ループの catch まで伝播し、直前の depth の結果が使用される旨をセクション 5.5.2 に明記すること。

**[P1-3] TimeAllocator のパス影響に対する安全性の説明不足**
- **出典**: Approach
- **内容**: `EstimateRemainingMoves` はパスの影響について「やや多めに見積もる」と記載するのみで、最悪ケースの分析がない。連続パスにより自分の手番数が想定より多くなる場合、1 手あたりの配分時間が不足する可能性がある。
- **修正方針**: パスによる手番偏りの最悪ケース（例: 終盤で相手が連続パスし自分が 5 手連続で指す場合）を記載し、現在の推定式と `MinTimeLimitMs` による最低保証の組み合わせでこのケースが安全に処理されることを説明に追記すること。

**[P1-4] TimeAllocator の DI 設計方針が未記載**
- **出典**: Quality
- **内容**: `FindBestMover` 内で `TimeAllocator` を直接インスタンス化しているが、既存コードベースでは `DiProvider.Get().GetService<T>()` パターンが多用されている。DI を使用しない判断の根拠が記載されていない。
- **修正方針**: `TimeAllocator` が状態を持たない純粋な計算クラスであり DI 登録が不要である旨を記載するか、あるいは `ITimeAllocator` インターフェースを定義して DI 経由で注入する設計に変更すること。

**[P1-5] SearchTimeoutException の外部漏洩に対する防御策が未記載**
- **出典**: Security
- **内容**: `SearchTimeoutException` は `Search()` メソッド内で catch される設計であるが、将来のコード変更で catch 漏れが発生した場合の防御がない。
- **修正方針**: `SearchTimeoutException` の Doc コメントに「Search() 内で必ず catch されるため外部伝播しない。コードレビュー時の確認ポイントとする」旨を明記すること。

---

*注記: Approach P1-2（分岐係数 3 倍の MPC 有効時の妥当性）は上位 5 件から溢れたため省略した。内容は「MPC 有効時の実効分岐係数（約 2 倍）への言及と、将来的な切り替え拡張の可能性を記載する」というものである。*

## 記録のみ (P2)

- SafetyMarginRatio の 5% が短時間対局（持ち時間 1 分等）で十分かどうかの検証計画が未記載である。フェーズ 4 の検証項目に追加することが望ましい（出典: Approach）
- `TimeLimitMs` 設定時に `MaxDepth` のデフォルト値が低いと時間に余裕があっても探索が浅く終了する可能性がある。`TimeLimitMs` 使用時の `MaxDepth` の扱いを検討することが望ましい（出典: Approach）
- `Stopwatch` の精度は OS とハードウェアに依存する。現在のターゲット環境では問題ないが、将来のクロスプラットフォーム展開時に留意すべき事項である（出典: Security）
- `RemainingTimeMs` に負の値や 0 が設定された場合の挙動が未定義である。将来的にプロトコル層から自動設定される際の入力バリデーションを検討することが望ましい（出典: Security）
- `PvsSearchEngine` の `_stopwatch` は Singleton 利用で複数回の `Search()` 呼び出し時に再利用されるが、`Restart()` により正常動作する。将来の並列化時にはスレッドセーフティの検討が必要だが、Non-Goals と整合している（出典: Quality）

## 要判断（矛盾する指摘）

該当なし
