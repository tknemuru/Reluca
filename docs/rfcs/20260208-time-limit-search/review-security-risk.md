## Security & Risk Reviewer によるレビュー結果

### 1. 判定 (Decision)

- **Status**: Approve

**判定基準:** P0 が1件以上存在する場合は Request Changes とする。P0 が0件の場合は Approve とする。

### 2. 良い点 (Strengths)

- **セクション 7.3 (後方互換性)**: `TimeLimitMs = null` がデフォルトであり、既存の全呼び出し元・全テストに対して破壊的変更がゼロである点が優れている。
- **セクション 5.4 (SearchTimeoutException)**: 例外クラスを「エンジン内部でのみ catch」と明記しており、例外が外部に漏洩するリスクを意識した設計である。
- **セクション 5.5.2 (レイヤー 1/2 の 2 段構え)**: レイヤー 1 で予防的に判断し、レイヤー 2 が安全ネットとして機能する多層防御の設計は、制限時間超過リスクに対して堅牢である。
- **セクション 9 (実装計画)**: 4 フェーズに分割し、各フェーズで後方互換性を検証する計画は段階的なリスク軽減として妥当である。
- **セクション 5.6.1 (MinTimeLimitMs)**: 最低保証時間 100ms を設けることで、極端に短い制限時間でも depth=1 の結果が保証される安全策が組み込まれている。

### 3. 指摘事項 (Issues)

#### Severity 定義

| Severity | 名称 | 定義 | Author の対応 |
| :--- | :--- | :--- | :--- |
| **P0 (Blocker)** | 修正必須 | 論理的欠陥、仕様漏れ、重大なリスク、回答必須の質問 | 必ず対応 |
| **P1 (Improvement)** | 具体的改善 | 修正内容と期待効果が明確な具体的改善提案 | 原則対応 |
| **P2 (Note)** | 記録のみ | 代替案の提示、将来的な懸念、参考情報 | 対応不要 |

#### 指摘一覧

**P0:** 該当なし

**[P1-1] SearchTimeoutException が外部に漏洩した場合のリスク緩和策が未記載**
- **対象セクション**: 5.4 タイムアウト中断用の例外クラス / 5.5.2 反復深化ループの時間制御
- **内容**: `SearchTimeoutException` は `Search()` メソッド内で catch される設計であるが、今後のコード変更で catch 漏れが発生した場合、呼び出し元に未処理例外として伝播するリスクがある。現時点では `Search()` の try-catch のみが防御線であり、多重防御がない。
- **修正の期待値**: `ISearchEngine.Search()` の呼び出し側（`FindBestMover.Move()` 等）においても `SearchTimeoutException` を catch するガード節を追加するか、あるいは `SearchTimeoutException` のドキュメントに「Search() 内で必ず catch されるため外部伝播しない」旨を明記し、コードレビュー時のチェックポイントとすること。

**[P1-2] depth=1 の探索自体がタイムアウトした場合の挙動が未定義**
- **対象セクション**: 5.5.2 反復深化ループの時間制御
- **内容**: Goals に「最低 depth=1 の探索結果が保証される」と記載があるが、depth=1 の探索中にレイヤー 2 のタイムアウトが発生した場合、`completedDepth = 0` かつ `result = new SearchResult(-1, 0)` のまま返却される。この場合 `BestMove = -1` は無効な着手であり、呼び出し元が処理できない可能性がある。
- **修正の期待値**: depth=1 の探索中はレイヤー 2 のタイムアウトチェックを無効化するか、または `BestMove = -1` が返却された場合の呼び出し元の対処方針を記載すること。

**[P2-1] Stopwatch の精度がプラットフォーム依存である点への言及**
- **対象セクション**: 5.5.3 ノード展開時のタイムアウトチェック / 7.1 パフォーマンス
- **内容**: `System.Diagnostics.Stopwatch` の精度は OS とハードウェアに依存する。Windows では通常 100ns 精度であるが、一部の環境では精度が低下する可能性がある。本 RFC のターゲット環境（.NET 8.0 / Linux WSL2）では高精度タイマーが利用可能と想定されるが、将来的にクロスプラットフォーム展開する場合に留意すべき事項である。

**[P2-2] RemainingTimeMs の設定が外部依存であり、不正値への防御がない**
- **対象セクション**: 5.6.3 FindBestMover との統合
- **内容**: `RemainingTimeMs` は public プロパティとして公開されるが、負の値や 0 が設定された場合の挙動が未定義である。`TimeAllocator.Allocate()` に負の値が渡された場合、`availableMs` が負になり予期しない配分結果が返される可能性がある。将来的にプロトコル層から設定される際に不正値が流入するリスクがある。
