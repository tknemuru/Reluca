## Technical Quality Reviewer によるレビュー結果

### 1. 判定 (Decision)

- **Status**: Request Changes

**判定基準:** P0 が1件以上存在する場合は Request Changes とする。P0 が0件の場合は Approve とする。

### 2. 良い点 (Strengths)

- **セクション 5.5.3 (タイムアウトチェック)**: ビット AND によるモジュロ演算（`_nodesSearched & (TimeoutCheckInterval - 1)`）は、ホットパスにおけるオーバーヘッドを最小化する実装として適切である。
- **セクション 5.5.2 (探索ループ構造)**: try-catch を反復深化ループ内に配置し、タイムアウト時に直前深さの結果をそのまま利用する構造は、既存の反復深化のセマンティクスを自然に拡張している。
- **セクション 5.2 / 5.3 (SearchOptions / SearchResult)**: コンストラクタのデフォルト引数により後方互換を維持しつつ拡張する設計は、既存コードベースのパターンと一貫している。
- **セクション 7.1 (パフォーマンス)**: タイムアウトチェックのオーバーヘッドを数値的に見積もっており（0.01% 未満）、性能影響の定量評価が行われている。
- **セクション 8 (テスト戦略)**: ユニットテストと統合テストの両面で網羅的な検証項目が定義されている。

### 3. 指摘事項 (Issues)

#### Severity 定義

| Severity | 名称 | 定義 | Author の対応 |
| :--- | :--- | :--- | :--- |
| **P0 (Blocker)** | 修正必須 | 論理的欠陥、仕様漏れ、重大なリスク、回答必須の質問 | 必ず対応 |
| **P1 (Improvement)** | 具体的改善 | 修正内容と期待効果が明確な具体的改善提案 | 原則対応 |
| **P2 (Note)** | 記録のみ | 代替案の提示、将来的な懸念、参考情報 | 対応不要 |

#### 指摘一覧

**[P0-1] _nodesSearched のカウンタオーバーフローによるタイムアウトチェック不達のリスク**
- **対象セクション**: 5.5.3 ノード展開時のタイムアウトチェック
- **内容**: `_nodesSearched` は `long` 型と推測されるが、RFC 内でその型が明示されていない。仮に `int` 型であった場合、深い探索や長時間の探索で `int.MaxValue`（約 21 億）を超えるとオーバーフローが発生し、ビット AND によるタイムアウトチェック条件が意図通りに動作しなくなる可能性がある。`_nodesSearched` が既存コードで `long` 型であることを確認し、RFC に型を明記すべきである。
- **修正の期待値**: `_nodesSearched` のフィールド定義（型を含む）を RFC に明記すること。既存コードが `int` 型である場合は `long` 型への変更を変更対象に追加すること。

**[P1-1] TimeAllocator クラスの DI 設計方針が不明確**
- **対象セクション**: 5.6.3 FindBestMover との統合 / 5.6.1 TimeAllocator クラス
- **内容**: `FindBestMover` 内で `_timeAllocator ??= new TimeAllocator()` と直接インスタンス化しているが、既存コードベースでは `DiProvider.Get().GetService<T>()` パターンが多用されている。`TimeAllocator` を DI 登録せず直接生成する判断の根拠が記載されていない。テスト時に配分戦略をモック化したい場合、現在の設計では困難である。
- **修正の期待値**: `TimeAllocator` を DI 登録する、またはインターフェース `ITimeAllocator` を定義して DI 経由で注入する設計に変更すること。あるいは DI を使用しない判断の根拠（状態を持たない純粋な計算クラスである等）を記載すること。

**[P1-2] Aspiration Window のリトライが時間制御と干渉する可能性**
- **対象セクション**: 5.5.2 反復深化ループの時間制御
- **内容**: `AspirationRootSearch` は fail-high / fail-low 時にウィンドウを広げてリトライする機構を持つが、リトライ中のタイムアウト挙動について記載がない。リトライ途中で `SearchTimeoutException` が発生した場合、Aspiration Window のリトライループがどのように中断されるか、またその場合の `result` がどの値になるかが不明確である。
- **修正の期待値**: `AspirationRootSearch` 内で `SearchTimeoutException` が発生した場合の挙動を記載すること。例外が `AspirationRootSearch` を透過して `Search()` の catch に到達する設計であることを明記し、その場合に直前の depth の結果が使用されることを確認すること。

**[P2-1] PvsSearchEngine の Stopwatch フィールドがインスタンスレベルであることの影響**
- **対象セクション**: 5.5.1 インスタンスフィールドの追加
- **内容**: `_stopwatch` が `readonly` インスタンスフィールドとして定義されているが、`PvsSearchEngine` が DI コンテナから Singleton として取得される場合、複数回の `Search()` 呼び出しで同一の `Stopwatch` インスタンスが再利用される。`_stopwatch.Restart()` を `Search()` 冒頭で呼び出しているため正常に動作するが、将来的に並列化した場合はスレッドセーフティの問題が発生する。Non-Goals に並列探索を除外している点で整合はとれている。
